<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kaluo-zz.github.io</id>
    <title>KALUO</title>
    <updated>2019-07-18T06:45:36.618Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kaluo-zz.github.io"/>
    <link rel="self" href="https://kaluo-zz.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://kaluo-zz.github.io/images/avatar.png</logo>
    <icon>https://kaluo-zz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, KALUO</rights>
    <entry>
        <title type="html"><![CDATA[Linux静默安装matlab2019a]]></title>
        <id>https://kaluo-zz.github.io/post/linux-jing-mo-an-zhuang-matlab2019a</id>
        <link href="https://kaluo-zz.github.io/post/linux-jing-mo-an-zhuang-matlab2019a">
        </link>
        <updated>2019-07-18T02:47:20.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>下载<a href="http://zbh.ustc.edu.cn/zbh.php">matlab2019a</a>及其安装密钥；</p>
</li>
<li>
<p>安装</p>
</li>
</ol>
<pre><code>sudo mkdir /media/matlab
sudo /media/matlab/install -mode silent -fileInstallationKey key -agreeToLicense yes -licensePath /home/lab/network.lic -destinationFolder /usr/local/matlab2019a
sudo umount -l /media/matlab
</code></pre>
<ol start="3">
<li><code>sudo vi ~/.bashrc</code></li>
</ol>
<pre><code>alias matlab='/usr/local/matlab2019a/bin/matlab'
</code></pre>
<ol start="4">
<li><code>sudo vi /etc/bash.bashrc</code></li>
</ol>
<pre><code>export PATH=/usr/local/matlab2019a/bin${PATH:+:${PATH}}
</code></pre>
<ol start="5">
<li>
<p><code>source ~/.bashrc</code></p>
</li>
<li>
<p><code>matlab</code></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytorch可视化之Visdom]]></title>
        <id>https://kaluo-zz.github.io/post/pytorch-ke-shi-hua-zhi-visdom</id>
        <link href="https://kaluo-zz.github.io/post/pytorch-ke-shi-hua-zhi-visdom">
        </link>
        <updated>2019-07-11T11:29:57.000Z</updated>
        <content type="html"><![CDATA[<p>Visdom <a href="https://github.com/facebookresearch/visdom">github主页</a></p>
<p>Visdom旨在(远程)数据的可视化，并强调支持科学实验。</p>
<p>安装：<code>pip install visdom</code></p>
<p>启动：<code>python -m visdom.server</code></p>
<p>使用：</p>
<p>文件：visdom_plotter.py</p>
<pre><code>from visdom import Visdom
import numpy as np

class VisdomPlotter(object):
    def __init__(self, env_name = 'main'):
        self.viz = Visdom()
        self.env = env_name
        self.plots = {}
    
    def plot(self, var_name, split_name, title_name, x, y):
        if var_name not in self.plots:
            self.plots[var_name] = self.viz.line(X=np.array([x,x]), Y=np.array([y,y]), env=self.env, opts=dict(
                legend=[split_name],
                title=title_name,
                xlabel='Epochs',
                ylabel=var_name
            ))
        else:
            self.viz.line(X=np.array([x]), Y=np.array([y]), env=self.env, 
                            win=self.plots[var_name], name=split_name, update = 'append')
    
    def draw_image(self, title_name, img):
        self.viz.image(img, env=self.env, opts=dict(
                title = title_name
            ))
</code></pre>
<p>文件main.py</p>
<pre><code>import numpy as np
import torch
from utils.visdom_plotter import VisdomPlotter

visdom_plotter = VisdomPlotter()
...
visdom_plotter.draw_image('img_name',  img) # img : C x H x W
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用ffmpeg将一组图像转换为视频]]></title>
        <id>https://kaluo-zz.github.io/post/shi-yong-ffmpeg-jiang-yi-zu-tu-xiang-zhuan-huan-wei-shi-pin</id>
        <link href="https://kaluo-zz.github.io/post/shi-yong-ffmpeg-jiang-yi-zu-tu-xiang-zhuan-huan-wei-shi-pin">
        </link>
        <updated>2019-07-10T02:01:19.000Z</updated>
        <content type="html"><![CDATA[<p>当使用<code>ffmpeg</code>压缩视频时，建议使用<code>libx264</code>编解码器。在将图片转换为视频前，建议将图片名称更改为(<code>pic0001.png</code>, <code>pic0002.png</code>)之类的有序形式。相关命令：</p>
<pre><code>ffmpeg -r 60 image2 -s 1920x1080 -i pic%04d.png -vcodec libx264 -crf 25 -pix_fmt yuv420p test.mp4
</code></pre>
<ul>
<li><code>-r</code> 帧率(fps)</li>
<li><code>-crf</code> 质量，更低意味着更好的质量（一般15-25）</li>
<li><code>-pix_fmt yuv420p</code> 指定像素格式</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Distance Transform]]></title>
        <id>https://kaluo-zz.github.io/post/distance-transform</id>
        <link href="https://kaluo-zz.github.io/post/distance-transform">
        </link>
        <updated>2019-07-08T12:58:51.000Z</updated>
        <content type="html"><![CDATA[<p>Distance Transform</p>
<p>现在有这样一种需求，产生由点构成的曲线段的热图。如何产生呢？</p>
<p>首先介绍一下Distance transform。距离变换提供了图像中点的分离的度量，它处理的对象是二值图像。其基本思想是每个像素值赋值为其与最近的背景像素点之间的距离（常用的距离度量是欧式距离和曼哈顿距离）。</p>
<p>下面以一张图像为例。从上到下分别是原图、原图+轮廓点、轮廓点、经过距离变换后的图和经过标准化和阈值化后图。这样就得到了由轮廓点产生的边界线热图。</p>
<p><img src="https://kaluo-zz.github.io/post-images/1562725172655.png" alt="">
<img src="https://kaluo-zz.github.io/post-images/1562725181225.png" alt="">
<img src="https://kaluo-zz.github.io/post-images/1562725185714.png" alt="">
<img src="https://kaluo-zz.github.io/post-images/1562725226765.png" alt="">
<img src="https://kaluo-zz.github.io/post-images/1562725230518.png" alt=""></p>
<p>步骤如下：</p>
<ol>
<li>
<p>获取图像轮廓点；</p>
</li>
<li>
<p>得到与原图大小一样的二值图像B，轮廓点对应位置为0，其余位置为1；</p>
</li>
<li>
<p>使用<code>scipy.ndimage.distance_transform</code>函数来转换二值图像B，得到结果D；</p>
</li>
<li>
<p>将D中的最大值减去D中的每一个元素；</p>
</li>
<li>
<p>对D进行标准化；</p>
</li>
<li>
<p>利用对D中的每个像素进行处理。</p>
</li>
</ol>
<p class='katex-block katex-error' title='Error: Expected node of type ordgroup, but got node of type text'>   M(x, y) = \left\{
   \begin{array}
   	\text{exp}(-\frac{D(x, y)^2}{2\sigma^2}), &amp;\text{if}\; D(x, y) &lt; 3\sigma \\
   	0, &amp;\text{otherwise}
   \end{array}
   \right.
</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python属性访问]]></title>
        <id>https://kaluo-zz.github.io/post/python-shu-xing-fang-wen</id>
        <link href="https://kaluo-zz.github.io/post/python-shu-xing-fang-wen">
        </link>
        <updated>2019-07-03T13:21:28.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><code>__getattr__(self, name)</code>：访问不存在的属性时自动调用</li>
<li><code>__getattribute__(self, name)</code>：访问存在的属性时自动调用（先调用该方法，查看是否存在该属性，若不存在，调用<code>__getattr__</code>。若重载了<code>__getattribute__</code>方法，则不会自动调用<code>__getattr__</code>方法，需在最后手动添加一行<code>object.__getattribute__(self, name)</code>。）。</li>
<li><code>__setattr__(self, name)</code>：设置实例对象的一个新的属性时自动调用</li>
<li><code>__delattr__(self, name)</code>：删除一个实例对象的属性时自动调用</li>
</ol>
<p>（python中无论实例还是类，都是用<code>__dict__</code>来存储属性和方法）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows创建软链接]]></title>
        <id>https://kaluo-zz.github.io/post/windows-chuang-jian-ruan-lian-jie</id>
        <link href="https://kaluo-zz.github.io/post/windows-chuang-jian-ruan-lian-jie">
        </link>
        <updated>2019-07-03T11:11:49.000Z</updated>
        <content type="html"><![CDATA[<p>打开cmd，在当前目录下创建链接到<code>D:\Files\COCO\images</code>的软链接：
<code>mklink /J images D:\Files\COCO\images</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytorch中文文档]]></title>
        <id>https://kaluo-zz.github.io/post/pytorch-zhong-wen-wen-dang</id>
        <link href="https://kaluo-zz.github.io/post/pytorch-zhong-wen-wen-dang">
        </link>
        <updated>2019-07-03T09:23:26.000Z</updated>
        <content type="html"><![CDATA[<p>Pytorch中文文档：<a href="https://pytorch-cn.readthedocs.io/zh/latest/package_references/torch/">-&gt;</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jupyter notebook快捷键]]></title>
        <id>https://kaluo-zz.github.io/post/jupyter-notebook-kuai-jie-jian</id>
        <link href="https://kaluo-zz.github.io/post/jupyter-notebook-kuai-jie-jian">
        </link>
        <updated>2019-07-02T00:23:39.000Z</updated>
        <content type="html"><![CDATA[<p><code>Esc</code> 切换到命令模式，在命令模式下，继续按以下键：
<code>A</code> 在当前单元格上方创建一个单元格
<code>B</code> 在当前单元格下方创建一个单元格
<code>DD</code> 删除当前单元格
<code>S</code> 手动保存笔记本
<code>L</code> 打开、关闭行号
<code>H</code> 查询命令行
<code>Y</code> 从markdown切换到单元格
<code>M</code> 从单元格切换到markdown</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pytorch之数据维度变换]]></title>
        <id>https://kaluo-zz.github.io/post/pytorch-zhi-shu-ju-wei-du-bian-huan</id>
        <link href="https://kaluo-zz.github.io/post/pytorch-zhi-shu-ju-wei-du-bian-huan">
        </link>
        <updated>2019-07-01T13:43:30.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><code>torch.cat(inputs, dimension=0) → Tensor</code>：在给定的维度上进行张量序列的拼接。</li>
</ol>
<pre><code>import torch

x = torch.rand((71, 32, 1))
# x.shape = torch.Size([71, 32, 1])
px = torch.cat((torch.zeros(29, 32, 1, dtype=x.dtype, device=x.device), x), 0)
# px.shape = torch.Size([100, 32, 1])
</code></pre>
<ol start="2">
<li><code>view(*args) -&gt; Tensor</code>：返回一个有相同数据但尺寸不同的tensor。操作的tensor必须是连续的（<code>contiguous()</code>）。</li>
</ol>
<pre><code>&gt;&gt;&gt; x = torch.randn(4, 4)
&gt;&gt;&gt; x.size()
torch.Size([4, 4])
&gt;&gt;&gt; y = x.view(16)
&gt;&gt;&gt; y.size()
torch.Size([16])
&gt;&gt;&gt; z = x.view(-1, 8)  # the size -1 is inferred from other dimensions
&gt;&gt;&gt; z.size()
torch.Size([2, 8])
</code></pre>
<ol start="3">
<li><code>permute(dims)</code>：将tensor的维度换位。</li>
</ol>
<pre><code>&gt;&gt;&gt; x = torch.randn(2, 3, 5)
&gt;&gt;&gt; x.size()
torch.Size([2, 3, 5])
&gt;&gt;&gt; x.permute(2, 0, 1).size()
torch.Size([5, 2, 3])
</code></pre>
<ol start="4">
<li><code>repeat(*sizes)</code>：沿着指定的维度重复tensor（sizes (torch.Size ot int...)-沿着每一维重复的次数）。</li>
</ol>
<pre><code>&gt;&gt;&gt; x = torch.Tensor([1, 2, 3])
&gt;&gt;&gt; x.repeat(4, 2) # 沿着维度0重复4次，沿着维度1重复2次
 1  2  3  1  2  3
 1  2  3  1  2  3
 1  2  3  1  2  3
 1  2  3  1  2  3
[torch.FloatTensor of size 4x6]
&gt;&gt;&gt; x.repeat(4, 2, 1).size()
torch.Size([4, 2, 3])
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用TensorRT对模型进行压缩加速]]></title>
        <id>https://kaluo-zz.github.io/post/shi-yong-tensorrt-dui-mo-xing-jin-xing-ya-suo-jia-su</id>
        <link href="https://kaluo-zz.github.io/post/shi-yong-tensorrt-dui-mo-xing-jin-xing-ya-suo-jia-su">
        </link>
        <updated>2019-07-01T08:30:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="安装tensorrt5122">安装TensorRT5.1.2.2</h3>
<ol>
<li>
<p>到NVIDIA<a href="https://developer.nvidia.com/tensorrt">官网</a>下载对应Ubuntu系统的TensorRT5.1.2.2。</p>
</li>
<li>
<p>新建目录TensorRT，将下载的文件移动至该目录下，并解压：</p>
<pre><code class="language-bash">username@hostname:~/TensorRT$ tar xzvf TensorRT-5.1.2.2.Ubuntu-16.04.4.x86_64-gnu.cuda-9.0.cudnn7.5.tar.gz
</code></pre>
</li>
<li>
<p>添加TensorRT的绝对路径<code>LIB</code>目录到环境变量<code>LD_LIBRARY_PATH</code>:</p>
<pre><code class="language-bash">username@hostname:~/TensorRT/TensorRT-5.1.2.2$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/kaluo/TensorRT/TensorRT-5.1.2.25/lib
</code></pre>
</li>
<li>
<p>安装Python TensorRT wheel文件</p>
<pre><code class="language-bash">username@hostname:~/TensorRT/TensorRT-5.1.2.2$ cd python/
username@hostname:~/TensorRT/TensorRT-5.1.2.2/python$ ls
tensorrt-5.1.2.2-cp27-none-linux_x86_64.whl
tensorrt-5.1.2.2-cp34-none-linux_x86_64.whl
tensorrt-5.1.2.2-cp35-none-linux_x86_64.whl
tensorrt-5.1.2.2-cp36-none-linux_x86_64.whl
tensorrt-5.1.2.2-cp37-none-linux_x86_64.whl
username@hostname:~/TensorRT/TensorRT-5.1.2.2/python$ pip install tensorrt-5.1.2.2-cp27-none-linux_x86_64.whl #这里使用python2.7
Processing ./tensorrt-5.1.2.2-cp27-none-linux_x86_64.whl
Installing collected packages: tensorrt
Successfully installed tensorrt-5.1.2.2
</code></pre>
</li>
<li>
<p>如果需要将TensorRT和TensorFlow一起使用，则需要安装python UFF wheel文件。</p>
<pre><code class="language-bash">username@hostname:~/TensorRT/TensorRT-5.1.2.2$ cd uff/
username@hostname:~/TensorRT/TensorRT-5.1.2.2/uff$ ls
uff-0.6.3-py2.py3-none-any.whl
username@hostname:~/TensorRT/TensorRT-5.1.2.2/uff$ pip install uff-0.6.3-py2.py3-none-any.whl
</code></pre>
</li>
<li>
<p>安装python <code>graphsurgeon</code> wheel文件。</p>
<pre><code class="language-bash">username@hostname:~/TensorRT/TensorRT-5.1.2.2/graphsurgeon$ pip install graphsurgeon-0.4.0-py2.py3-none-any.whl
Processing ./graphsurgeon-0.4.0-py2.py3-none-any.whl
Installing collected packages: graphsurgeon
Successfully installed graphsurgeon-0.4.0
</code></pre>
</li>
</ol>
<blockquote>
<h3 id="43-tar-file-installation"><a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-install-guide/index.html#installing-tar">4.3. Tar File Installation</a></h3>
<p>Note: Before issuing the following commands, you'll need to replace 5.1.x.x with your specific TensorRT version. The following commands are examples.</p>
<ol>
<li>
<p>Install the following dependencies, if not already present:</p>
<ul>
<li>Install the CUDA Toolkit 9.0, 10.0 or 10.1</li>
<li>cuDNN 7.5.0</li>
<li>Python 2 or Python 3 (Optional)</li>
</ul>
</li>
<li>
<p><a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-install-guide/index.html#downloading">Download</a> the TensorRT tar file that matches the Linux distribution you are using.</p>
</li>
<li>
<p>Choose where you want to install TensorRT. This tar file will install everything into a subdirectory called TensorRT-5.1.x.x.</p>
</li>
<li>
<p>Unpack the tar file.</p>
<pre><code class="language-bash">$ tar xzvf TensorRT-5.1.x.x.Ubuntu-1x.04.x.x86_64-gnu.cuda-x.x.cudnn7.x.tar.gz
</code></pre>
<p>Where:</p>
<ul>
<li>5.1.x.x is your TensorRT version</li>
<li>Ubuntu-1x.04.x is 14.04.5, 16.04.4 or 18.04.1</li>
<li>cuda-x.x is CUDA version 9.0, 10.0, or 10.1</li>
<li>cudnn7.x is cuDNN version 7.5</li>
</ul>
<p>This directory will have sub-directories like <code>lib</code>, <code>include</code>,<code>data</code>, etc…</p>
<pre><code class="language-bash">$ ls TensorRT-5.1.x.x
bin  data  doc  graphsurgeon  include  lib  python  samples  targets  TensorRT-Release-Notes.pdf  uff
</code></pre>
</li>
<li>
<p>Add the absolute path to the TensorRT lib directory to the environment variable LD_LIBRARY_PATH:</p>
<pre><code class="language-bash">$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;eg:TensorRT-5.1.x.x/lib&gt;
</code></pre>
</li>
<li>
<p>Install the Python TensorRT wheel file.</p>
<pre><code class="language-bash">$ cd TensorRT-5.1.x.x/python
</code></pre>
<pre><code class="language-bash">$ sudo pip2 install tensorrt-5.1.x.x-cp27-none-linux_x86_64.whl
</code></pre>
<pre><code class="language-bash">$ sudo pip3 install tensorrt-5.1.x.x-cp3x-none-linux_x86_64.whl
</code></pre>
</li>
<li>
<p>Install the Python UFF wheel file. This is only required if you plan to use TensorRT with TensorFlow.</p>
<pre><code class="language-bash">$ cd TensorRT-5.1.x.x/uff
</code></pre>
<pre><code class="language-bash">$ sudo pip2 install uff-0.6.3-py2.py3-none-any.whl
</code></pre>
<pre><code class="language-bash">$ sudo pip3 install uff-0.6.3-py2.py3-none-any.whl
</code></pre>
<pre><code class="language-bash">$ which convert-to-uff
/usr/local/bin/convert-to-uff
</code></pre>
</li>
<li>
<p>Install the Python graphsurgeon wheel file.</p>
<pre><code class="language-bash">$ cd TensorRT-5.1.x.x/graphsurgeon
</code></pre>
<pre><code class="language-bash">$ sudo pip2 install graphsurgeon-0.4.0-py2.py3-none-any.whl
</code></pre>
<pre><code class="language-bash">$ sudo pip3 install graphsurgeon-0.4.0-py2.py3-none-any.whl
</code></pre>
</li>
<li>
<p>Verify the installation:</p>
<ol>
<li>Ensure that the installed files are located in the correct directories. For example, run the tree -d command to check whether all supported installed files are in place in the lib, include, data, etc… directories.</li>
<li>Build and run one of the shipped samples, for example, sampleMNIST in the installed directory. You should be able to compile and execute the sample without additional settings. For more information about sampleMNSIT, see the <a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-sample-support-guide/index.html#mnist_sample">TensorRT Sample Support Guide</a>.</li>
<li>The Python samples are in the samples/python directory.</li>
</ol>
</li>
</ol>
</blockquote>
<h1 id="pip-install-error-with-pycuda">Pip install error with PyCUDA</h1>
<h2 id="problem">Problem</h2>
<ul>
<li>
<p>I tried to install PyCUDA using <code>pip</code>:</p>
</li>
<li>
<p>The installation tries to compile a few C++ files and it failed on the very first file with this error:</p>
<pre><code class="language-bash">In file included from src/cpp/cuda.cpp:1:0:
src/cpp/cuda.hpp:14:18: fatal error: cuda.h: No such file or directory
#include &lt;cuda.h&gt;
                ^
compilation terminated.
error: command 'x86_64-linux-gnu-gcc' failed with exit status 1
</code></pre>
</li>
</ul>
<h2 id="investigation">Investigation</h2>
<p>This error was strange because I had set <code>CUDA_ROOT</code> and had added the <code>bin</code> path of CUDA installation to <code>PATH</code> environment variable. So, the installer should have found <code>cuda.h</code> which I could see was present in <code>$CUDA_ROOT/include</code></p>
<p>To see what was happening, I tried the same command with verbosity:</p>
<pre><code class="language-bash">$ sudo pip -vvv install pycuda
</code></pre>
<ul>
<li>Now I could see that it was failing to find <code>nvcc</code>.</li>
<li>On downloading the source code of PyCUDA and checking <code>setup.py</code>, I saw that the check for <code>nvcc</code> was used to figure out the <code>CUDA_ROOT</code> and <code>CUDA_INC_DIR</code>.</li>
<li>The reason <code>nvcc</code> was not visible was that <code>CUDA_ROOT</code> was set for my user, but this <code>PATH</code> is not visible when a command is run under <code>sudo</code>, as described here. The solution was to make the CUDA <code>bin</code> path visible to <code>sudo</code>.</li>
</ul>
<h2 id="solution">Solution</h2>
<p>To make the <code>$CUDA_ROOT/bin</code> available in <code>PATH</code> for <code>sudo</code>, we can follow the steps described here. For example, on my system with CUDA 7.0 I followed these steps:</p>
<ul>
<li>
<p>Created a new file <code>/etc/profile.d/cuda.sh</code> and added this line:</p>
<pre><code class="language-bash">export PATH=/usr/local/cuda-7.0/bin:$PATH
</code></pre>
</li>
<li>
<p>Opened <code>root</code> shell without resetting <code>PATH</code> and ran the pip installation:</p>
</li>
</ul>
<pre><code class="language-bash">$ sudo su -
$ pip install pycuda
</code></pre>
<p>This worked and PyCUDA was installed successfully!</p>
]]></content>
    </entry>
</feed>