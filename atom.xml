<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kaluo-zz.github.io</id>
    <title>KALUO</title>
    <updated>2019-07-19T07:44:49.397Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kaluo-zz.github.io"/>
    <link rel="self" href="https://kaluo-zz.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://kaluo-zz.github.io/images/avatar.png</logo>
    <icon>https://kaluo-zz.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, KALUO</rights>
    <entry>
        <title type="html"><![CDATA[利用torch.matmul实现batch multiplication]]></title>
        <id>https://kaluo-zz.github.io/post/li-yong-torchmatmul-shi-xian-batch-multiplication</id>
        <link href="https://kaluo-zz.github.io/post/li-yong-torchmatmul-shi-xian-batch-multiplication">
        </link>
        <updated>2019-07-19T07:33:00.000Z</updated>
        <content type="html"><![CDATA[<p>【<code>torch.matmul</code>】</p>
<p><code>torch.matmul(tensor1, tensor2, out=None) → Tensor</code></p>
<pre><code>&gt;&gt;&gt; # vector x vector
&gt;&gt;&gt; tensor1 = torch.randn(3)
&gt;&gt;&gt; tensor2 = torch.randn(3)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([])
&gt;&gt;&gt; # matrix x vector
&gt;&gt;&gt; tensor1 = torch.randn(3, 4)
&gt;&gt;&gt; tensor2 = torch.randn(4)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([3])
&gt;&gt;&gt; # batched matrix x broadcasted vector
&gt;&gt;&gt; tensor1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; tensor2 = torch.randn(4)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([10, 3])
&gt;&gt;&gt; # batched matrix x batched matrix
&gt;&gt;&gt; tensor1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; tensor2 = torch.randn(10, 4, 5)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([10, 3, 5])
&gt;&gt;&gt; # batched matrix x broadcasted matrix
&gt;&gt;&gt; tensor1 = torch.randn(10, 3, 4)
&gt;&gt;&gt; tensor2 = torch.randn(4, 5)
&gt;&gt;&gt; torch.matmul(tensor1, tensor2).size()
torch.Size([10, 3, 5])
</code></pre>
<p>参考：https://pytorch.org/docs/stable/torch.html#torch.matmul</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux静默安装matlab2019a]]></title>
        <id>https://kaluo-zz.github.io/post/linux-jing-mo-an-zhuang-matlab2019a</id>
        <link href="https://kaluo-zz.github.io/post/linux-jing-mo-an-zhuang-matlab2019a">
        </link>
        <updated>2019-07-18T02:47:20.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>下载<a href="http://zbh.ustc.edu.cn/zbh.php">matlab2019a</a>及其安装密钥；</p>
</li>
<li>
<p>安装</p>
</li>
</ol>
<pre><code>sudo mkdir /media/matlab
sudo /media/matlab/install -mode silent -fileInstallationKey key -agreeToLicense yes -licensePath /home/lab/network.lic -destinationFolder /usr/local/matlab2019a
sudo umount -l /media/matlab
</code></pre>
<ol start="3">
<li><code>sudo vi ~/.bashrc</code></li>
</ol>
<pre><code>alias matlab='/usr/local/matlab2019a/bin/matlab'
</code></pre>
<ol start="4">
<li><code>sudo vi /etc/bash.bashrc</code></li>
</ol>
<pre><code>export PATH=/usr/local/matlab2019a/bin${PATH:+:${PATH}}
</code></pre>
<ol start="5">
<li>
<p><code>source ~/.bashrc</code></p>
</li>
<li>
<p><code>matlab</code></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytorch可视化之Visdom]]></title>
        <id>https://kaluo-zz.github.io/post/pytorch-ke-shi-hua-zhi-visdom</id>
        <link href="https://kaluo-zz.github.io/post/pytorch-ke-shi-hua-zhi-visdom">
        </link>
        <updated>2019-07-11T11:29:57.000Z</updated>
        <content type="html"><![CDATA[<p>Visdom <a href="https://github.com/facebookresearch/visdom">github主页</a></p>
<p>Visdom旨在(远程)数据的可视化，并强调支持科学实验。</p>
<p>安装：<code>pip install visdom</code></p>
<p>启动：<code>python -m visdom.server</code></p>
<p>使用：</p>
<p>文件：visdom_plotter.py</p>
<pre><code>from visdom import Visdom
import numpy as np

class VisdomPlotter(object):
    def __init__(self, env_name = 'main'):
        self.viz = Visdom()
        self.env = env_name
        self.plots = {}
    
    def plot(self, var_name, split_name, title_name, x, y):
        if var_name not in self.plots:
            self.plots[var_name] = self.viz.line(X=np.array([x,x]), Y=np.array([y,y]), env=self.env, opts=dict(
                legend=[split_name],
                title=title_name,
                xlabel='Epochs',
                ylabel=var_name
            ))
        else:
            self.viz.line(X=np.array([x]), Y=np.array([y]), env=self.env, 
                            win=self.plots[var_name], name=split_name, update = 'append')
    
    def draw_image(self, title_name, img):
        self.viz.image(img, env=self.env, opts=dict(
                title = title_name
            ))
</code></pre>
<p>文件main.py</p>
<pre><code>import numpy as np
import torch
from utils.visdom_plotter import VisdomPlotter

visdom_plotter = VisdomPlotter()
...
visdom_plotter.draw_image('img_name',  img) # img : C x H x W
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用ffmpeg将一组图像转换为视频]]></title>
        <id>https://kaluo-zz.github.io/post/shi-yong-ffmpeg-jiang-yi-zu-tu-xiang-zhuan-huan-wei-shi-pin</id>
        <link href="https://kaluo-zz.github.io/post/shi-yong-ffmpeg-jiang-yi-zu-tu-xiang-zhuan-huan-wei-shi-pin">
        </link>
        <updated>2019-07-10T02:01:19.000Z</updated>
        <content type="html"><![CDATA[<p>当使用<code>ffmpeg</code>压缩视频时，建议使用<code>libx264</code>编解码器。在将图片转换为视频前，建议将图片名称更改为(<code>pic0001.png</code>, <code>pic0002.png</code>)之类的有序形式。相关命令：</p>
<pre><code>ffmpeg -r 60 image2 -s 1920x1080 -i pic%04d.png -vcodec libx264 -crf 25 -pix_fmt yuv420p test.mp4
</code></pre>
<ul>
<li><code>-r</code> 帧率(fps)</li>
<li><code>-crf</code> 质量，更低意味着更好的质量（一般15-25）</li>
<li><code>-pix_fmt yuv420p</code> 指定像素格式</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Distance Transform]]></title>
        <id>https://kaluo-zz.github.io/post/distance-transform</id>
        <link href="https://kaluo-zz.github.io/post/distance-transform">
        </link>
        <updated>2019-07-08T12:58:51.000Z</updated>
        <content type="html"><![CDATA[<p>Distance Transform</p>
<p>现在有这样一种需求，产生由点构成的曲线段的热图。如何产生呢？</p>
<p>首先介绍一下Distance transform。距离变换提供了图像中点的分离的度量，它处理的对象是二值图像。其基本思想是每个像素值赋值为其与最近的背景像素点之间的距离（常用的距离度量是欧式距离和曼哈顿距离）。</p>
<p>下面以一张图像为例。从上到下分别是原图、原图+轮廓点、轮廓点、经过距离变换后的图和经过标准化和阈值化后图。这样就得到了由轮廓点产生的边界线热图。</p>
<p><img src="https://kaluo-zz.github.io/post-images/1562725172655.png" alt=""><br>
<img src="https://kaluo-zz.github.io/post-images/1562725181225.png" alt=""><br>
<img src="https://kaluo-zz.github.io/post-images/1562725185714.png" alt=""><br>
<img src="https://kaluo-zz.github.io/post-images/1562725226765.png" alt=""><br>
<img src="https://kaluo-zz.github.io/post-images/1562725230518.png" alt=""></p>
<p>步骤如下：</p>
<ol>
<li>
<p>获取图像轮廓点；</p>
</li>
<li>
<p>得到与原图大小一样的二值图像B，轮廓点对应位置为0，其余位置为1；</p>
</li>
<li>
<p>使用<code>scipy.ndimage.distance_transform</code>函数来转换二值图像B，得到结果D；</p>
</li>
<li>
<p>将D中的最大值减去D中的每一个元素；</p>
</li>
<li>
<p>对D进行标准化；</p>
</li>
<li>
<p>利用对D中的每个像素进行处理。</p>
</li>
</ol>
<p class='katex-block katex-error' title='Error: Expected node of type ordgroup, but got node of type text'>   M(x, y) = \left\{
   \begin{array}
   	\text{exp}(-\frac{D(x, y)^2}{2\sigma^2}), &amp;\text{if}\; D(x, y) &lt; 3\sigma \\
   	0, &amp;\text{otherwise}
   \end{array}
   \right.
</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python属性访问]]></title>
        <id>https://kaluo-zz.github.io/post/python-shu-xing-fang-wen</id>
        <link href="https://kaluo-zz.github.io/post/python-shu-xing-fang-wen">
        </link>
        <updated>2019-07-03T13:21:28.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><code>__getattr__(self, name)</code>：访问不存在的属性时自动调用</li>
<li><code>__getattribute__(self, name)</code>：访问存在的属性时自动调用（先调用该方法，查看是否存在该属性，若不存在，调用<code>__getattr__</code>。若重载了<code>__getattribute__</code>方法，则不会自动调用<code>__getattr__</code>方法，需在最后手动添加一行<code>object.__getattribute__(self, name)</code>。）。</li>
<li><code>__setattr__(self, name)</code>：设置实例对象的一个新的属性时自动调用</li>
<li><code>__delattr__(self, name)</code>：删除一个实例对象的属性时自动调用</li>
</ol>
<p>（python中无论实例还是类，都是用<code>__dict__</code>来存储属性和方法）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows创建软链接]]></title>
        <id>https://kaluo-zz.github.io/post/windows-chuang-jian-ruan-lian-jie</id>
        <link href="https://kaluo-zz.github.io/post/windows-chuang-jian-ruan-lian-jie">
        </link>
        <updated>2019-07-03T11:11:49.000Z</updated>
        <content type="html"><![CDATA[<p>打开cmd，在当前目录下创建链接到<code>D:\Files\COCO\images</code>的软链接：<br>
<code>mklink /J images D:\Files\COCO\images</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pytorch中文文档]]></title>
        <id>https://kaluo-zz.github.io/post/pytorch-zhong-wen-wen-dang</id>
        <link href="https://kaluo-zz.github.io/post/pytorch-zhong-wen-wen-dang">
        </link>
        <updated>2019-07-03T09:23:26.000Z</updated>
        <content type="html"><![CDATA[<p>Pytorch中文文档：<a href="https://pytorch-cn.readthedocs.io/zh/latest/package_references/torch/">-&gt;</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jupyter notebook快捷键]]></title>
        <id>https://kaluo-zz.github.io/post/jupyter-notebook-kuai-jie-jian</id>
        <link href="https://kaluo-zz.github.io/post/jupyter-notebook-kuai-jie-jian">
        </link>
        <updated>2019-07-02T00:23:39.000Z</updated>
        <content type="html"><![CDATA[<p><code>Esc</code> 切换到命令模式，在命令模式下，继续按以下键：<br>
<code>A</code> 在当前单元格上方创建一个单元格<br>
<code>B</code> 在当前单元格下方创建一个单元格<br>
<code>DD</code> 删除当前单元格<br>
<code>S</code> 手动保存笔记本<br>
<code>L</code> 打开、关闭行号<br>
<code>H</code> 查询命令行<br>
<code>Y</code> 从markdown切换到单元格<br>
<code>M</code> 从单元格切换到markdown</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pytorch之数据维度变换]]></title>
        <id>https://kaluo-zz.github.io/post/pytorch-zhi-shu-ju-wei-du-bian-huan</id>
        <link href="https://kaluo-zz.github.io/post/pytorch-zhi-shu-ju-wei-du-bian-huan">
        </link>
        <updated>2019-07-01T13:43:30.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><code>torch.cat(inputs, dimension=0) → Tensor</code>：在给定的维度上进行张量序列的拼接。</li>
</ol>
<pre><code>import torch

x = torch.rand((71, 32, 1))
# x.shape = torch.Size([71, 32, 1])
px = torch.cat((torch.zeros(29, 32, 1, dtype=x.dtype, device=x.device), x), 0)
# px.shape = torch.Size([100, 32, 1])
</code></pre>
<ol start="2">
<li><code>view(*args) -&gt; Tensor</code>：返回一个有相同数据但尺寸不同的tensor。操作的tensor必须是连续的（<code>contiguous()</code>）。</li>
</ol>
<pre><code>&gt;&gt;&gt; x = torch.randn(4, 4)
&gt;&gt;&gt; x.size()
torch.Size([4, 4])
&gt;&gt;&gt; y = x.view(16)
&gt;&gt;&gt; y.size()
torch.Size([16])
&gt;&gt;&gt; z = x.view(-1, 8)  # the size -1 is inferred from other dimensions
&gt;&gt;&gt; z.size()
torch.Size([2, 8])
</code></pre>
<ol start="3">
<li><code>permute(dims)</code>：将tensor的维度换位。</li>
</ol>
<pre><code>&gt;&gt;&gt; x = torch.randn(2, 3, 5)
&gt;&gt;&gt; x.size()
torch.Size([2, 3, 5])
&gt;&gt;&gt; x.permute(2, 0, 1).size()
torch.Size([5, 2, 3])
</code></pre>
<ol start="4">
<li><code>repeat(*sizes)</code>：沿着指定的维度重复tensor（sizes (torch.Size ot int...)-沿着每一维重复的次数）。</li>
</ol>
<pre><code>&gt;&gt;&gt; x = torch.Tensor([1, 2, 3])
&gt;&gt;&gt; x.repeat(4, 2) # 沿着维度0重复4次，沿着维度1重复2次
 1  2  3  1  2  3
 1  2  3  1  2  3
 1  2  3  1  2  3
 1  2  3  1  2  3
[torch.FloatTensor of size 4x6]
&gt;&gt;&gt; x.repeat(4, 2, 1).size()
torch.Size([4, 2, 3])
</code></pre>
]]></content>
    </entry>
</feed>